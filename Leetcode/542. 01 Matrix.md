---
title: 01 Matrix
difficulty: Medium
topics:
  - array
  - DFS
  - BFS
  - matrix
  - Topological Sort
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - Graphs
date: 2025-03-29
time: 
leetcode_id: 542
solved: true
review: true
---
[[LeetCode]]
[[Graphs]]
## [Problem](https://leetcode.com/problems/01-matrix/)
Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.

The distance between two cells sharing a common edge is `1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg)

**Input:** mat = [[0,0,0],[0,1,0],[0,0,0]]
**Output:** [[0,0,0],[0,1,0],[0,0,0]]

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg)

**Input:** mat = [[0,0,0],[0,1,0],[1,1,1]]
**Output:** [[0,0,0],[0,1,0],[1,2,1]]

**Constraints:**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 104`
- `1 <= m * n <= 104`
- `mat[i][j]` is either `0` or `1`.
- There is at least one `0` in `mat`.

**Note:** This question is the same as 1765: [https://leetcode.com/problems/map-of-highest-peak/](https://leetcode.com/problems/map-of-highest-peak/description/)


## My Approach
### Time: 
### BFS Approach/ TOPO sort
 ```python
 class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        q = deque()
        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        rows, cols = len(mat), len(mat[0])
  
        # First pass
        for row in range(rows):
            for col in range(cols):
                if mat[row][col] == 0:
                    q.append((row, col))
                else:
                    mat[row][col] = -1
  
        # Second Pass
        while q:
            row, col = q.popleft()
            for dr, dc in directions:
                if 0 <= row + dr < row and 0 <= col + dc < cols and mat[row + dr][col + dc] == -1:
                    mat[row + dr][col + dc] = mat[row][col] + 1
                    q.append((row + dr, col + dc))
  
        return mat
```
Here we go through the matrix one time to find the location of all the 0 cells. We add them to a queue. Then, we start at the 0 cells and go through each surrounding cell and update that to 1. We than add those to the end of the queue, and we keep iterating until all cells have been updated.

### Dynamic Programming Approach
```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        rows, cols = len(mat), len(mat[0])
  
        # First pass
        for row in range(rows):
            for col in range(cols):
                if mat[row][col] > 0:
                    top = mat[row - 1][col] if row > 0 else math.inf
                    left = mat[row][col - 1] if col > 0 else math.inf
                    mat[row][col] = min(top, left) + 1
  
        # Second Pass
        for row in range(rows - 1, -1, -1):
            for col in range(cols - 1, -1, -1):
                if mat[row][col] > 0:
                    bottom = mat[row + 1][col] if row < rows - 1 else math.inf
                    right = mat[row][col + 1] if col < cols - 1 else math.inf
                    mat[row][col] = min(mat[row][col], bottom + 1, right + 1)
        return mat
```
This approach is faster. We start by going from top left to bottom right, updating the value based on the smallest value from the top or from the left. Then we repeat that except in the opposite direction, from bottom right to top left. We update the value based on the smallest value from the bottom or the right, or if the original value is smaller. 
![[542. 01 Matrix.png]]



---
## [Solution](https://leetcode.com/problems/01-matrix/solutions/1369741/c-java-python-bfs-dp-solutions-with-picture-clean-concise-o-1-space)

**✔️ Solution 1: BFS on zero cells first**

- For convinience, let's call the cell with value 0 as **zero-cell**, the cell has with value 1 as **one-cell**, the distance of the nearest 0 of a cell as **distance**.
- Firstly, we can see that the distance of all **zero-cells** are 0.
- Same idea with Topology Sort, we process **zero-cells** first, then we use `queue` data structure to keep the order of processing cells, so that cells which have the smaller distance will be processed first. Then we expand the unprocessed neighbors of the current processing cell and push into our queue.
- Afterall, we can achieve the minimum distance of all cells in our matrix.

![image](https://assets.leetcode.com/users/images/0de8711a-bdd9-4da3-a094-012abe995508_1627576450.2849615.png)

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        DIR = [0, 1, 0, -1, 0]

        q = deque([])
        for r in range(m):
            for c in range(n):
                if mat[r][c] == 0:
                    q.append((r, c))
                else:
                    mat[r][c] = -1  # Marked as not processed yet!

        while q:
            r, c = q.popleft()
            for i in range(4):
                nr, nc = r + DIR[i], c + DIR[i + 1]
                if nr < 0 or nr == m or nc < 0 or nc == n or mat[nr][nc] != -1: continue
                mat[nr][nc] = mat[r][c] + 1
                q.append((nr, nc))
        return mat
```

**Complexity**

- Time: `O(M * N)`, where `M` is number of rows, `N` is number of columns in the matrix.
- Space: `O(M * N)`, space for the queue.

---

**✔️ Solution 2: Dynamic Programming**

- For convinience, let's call the cell with value 0 as **zero-cell**, the cell has with value 1 as **one-cell**, the distance of the nearest 0 of a cell as **distance**.
- Firstly, we can see that the distance of all **zero-cells** are 0, so we skip **zero-cells**, we process **one-cells** only.
- In DP, we can only use prevous values if they're already computed.
- In this problem, a cell has at most 4 neighbors that are left, top, right, bottom. If we use dynamic programming to compute the distance of the current cell based on 4 neighbors simultaneously, it's impossible because we are not sure if distance of neighboring cells is already computed or not.
- That's why, we need to compute the distance one by one:
    - Firstly, for a cell, we restrict it to only 2 directions which are left and top. Then we iterate cells from **top to bottom**, and from **left to right**, we calculate the distance of a cell **based on its left and top neighbors**.
    - Secondly, for a cell, we restrict it only have 2 directions which are right and bottom. Then we iterate cells from **bottom to top**, and from **right to left**, we update the distance of a cell **based on its right and bottom neighbors**.

![image](https://assets.leetcode.com/users/images/8da7965f-6cf4-4ac2-a307-33f661fea5ca_1627604534.7922251.png)

```python
class Solution:  # 520 ms, faster than 96.50%
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])

        for r in range(m):
            for c in range(n):
                if mat[r][c] > 0:
                    top = mat[r - 1][c] if r > 0 else math.inf
                    left = mat[r][c - 1] if c > 0 else math.inf
                    mat[r][c] = min(top, left) + 1

        for r in range(m - 1, -1, -1):
            for c in range(n - 1, -1, -1):
                if mat[r][c] > 0:
                    bottom = mat[r + 1][c] if r < m - 1 else math.inf
                    right = mat[r][c + 1] if c < n - 1 else math.inf
                    mat[r][c] = min(mat[r][c], bottom + 1, right + 1)

        return mat
```


**Complexity**

- Time: `O(M * N)`, where `M` is number of rows, `N` is number of columns in the matrix.
- Space: `O(1)`

If you think this **post is useful**, I'm happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.



---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```