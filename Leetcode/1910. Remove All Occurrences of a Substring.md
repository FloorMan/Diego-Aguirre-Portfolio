---
title: Remove All Occurrences of a Substring
difficulty: Medium
topics:
  - KMP
  - Stacks
  - Substrings
tags:
  - leetcode
  - daily
  - coding
date: 2025-02-11
time: 30:00
leetcode_id: 1910
---
[[LeetCode]]
## Notes
Honestly, first time trying a leetcode in a long time. Felt a little rusty, but I just need to focus on DSA. Stacks and KMP. Will implement later. 

## My approach

#### Timing
*30 minutes*

First I went for the naive approach of creating a new string every time I deleted a substring. 

```python 

class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        
        if len(part) > len(s): # If part is longer than s, we dont have to do anything
            return s

        result = s
        index = 0
        partLen = len(part)

        while index < (len(result) - partLen + 1):
            if result[index : index + partLen] == part:
                result = result[0 : index] + result[index + partLen:]
                index = 0
            else: 
                index += 1

        return result
```





---
## Solutions
###  <font color=00CED1>Approach 1: Iteration</font>
- [x] Implemented
#### Intuition

We are given a stringÂ `s`Â and a substringÂ `part`, and we need to repeatedly remove the first occurrence ofÂ `part`Â fromÂ `s`Â until it no longer appears. Since the constraints are relatively small (`s.length <= 1000`Â andÂ `part.length <= 1000`), we can try a brute force approach.

We can use a simple iterative approach which loops throughÂ `s`Â as long asÂ `part`Â is present in it. Each time we findÂ `part`, we need to remove its first occurrence. To do this, we first locate the leftmost occurrence ofÂ `part`Â inÂ `s`. Once we know where it starts, we can breakÂ `s`Â into three sections: the part of the string before the occurrence ofÂ `part`, the occurrence ofÂ `part`Â itself, and the part of the string afterÂ `part`. By combining the first and third sections (effectively leaving out the middle section), we remove that occurrence ofÂ `part`Â fromÂ `s`.

When the loop finishes,Â `s`Â will no longer contain any occurrences ofÂ `part`, so we return it as the result.

> Itâ€™s worth noting that we can simplify this process by utilizing built-in string methods provided by the programming language.  
> For instance, in Java, theÂ `String.replaceFirst`Â method can be used to replace the first occurrence of a substring, in Python3 we can useÂ `str.replace`, and in C++ we can use a combination ofÂ `std::string::erase`Â andÂ `std::string::find`.  
> Most of the time, it is beneficial to use these built-in functions since they are heavily optimized and tested, and will almost always perform better than our own implementations.

#### Algorithm

- Run aÂ `while`Â loop to repeatedly check if the stringÂ `s`Â contains the substringÂ `part`.
    - Find the index of the leftmost occurrence ofÂ `part`Â inÂ `s`Â and store it in a variableÂ `partStartIndex`.
    - Use the substring method to extract the portion ofÂ `s`Â beforeÂ `part`Â (`s.substring(0, partStartIndex)`) and the portion afterÂ `part`Â (`s.substring(partStartIndex + part.length())`).
    - Concatenate the first and last portions and assign it back toÂ `s`.
- Return the updated stringÂ `s`, which no longer contains any occurrences ofÂ `part`.

#### Implementation

```python
class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        # Continue removing occurrences of 'part' as long as it exists in 's'
        while part in s:
            # Find the index of the leftmost occurrence of 'part'
            part_start_index = s.find(part)

            # Remove the substring 'part' by concatenating segments before and after 'part'
            s = s[:part_start_index] + s[part_start_index + len(part) :]

        # Return the updated string after all occurrences are removed
        return s
```
#### Complexity Analysis

LetÂ nÂ be the length of the stringÂ sÂ andÂ mÂ be the length of the substringÂ `part`.

- Time complexity:Â O(n2)
    
    The algorithm uses aÂ `while`Â loop to repeatedly remove the leftmost occurrence ofÂ `part`Â fromÂ `s`. Each iteration of the loop involves finding the index ofÂ `part`, which takesÂ O(nâ‹…m)Â time, and then creating a new string by concatenating the segments before and afterÂ `part`, which takesÂ O(n)Â time. In the worst case, there areÂ O(n/m)Â such iterations (e.g., whenÂ `part`Â is non-overlapping and removed sequentially). The total time across all iterations isÂ O((nâ‹…m)â‹…(n/m))=O(n2).
    
- Space complexity:Â O(n)
    
    Although the algorithm does not explicitly use additional data structures, each iteration creates a new string by concatenating the segments before and after part. This results in the creation of intermediate strings, each of size up toÂ O(n). The space required to store these intermediate strings dominates the space complexity, leading toÂ O(n)Â space usage.
    

---

### <font color=00CED1>Approach 2: Stack</font>
- [x] Implemented
#### Intuition

In the first approach, we relied on built-in methods to find and remove substrings. Letâ€™s explore how to implement this functionality entirely on our own.

One issue with repeatedly removing substrings from a string is that it requires recreating the entire string every time. We need a way such that removing the substring characters from a string at any point is as close to constant time as possible.

We can simulate this using a stack. A stack allows us to remove its topmost element in constant time. So, if we incrementally put the characters ofÂ `s`Â in the stack, the moment we find out that the last part of the stack formsÂ `part`, we simply pop the entire substring out. This means we needed to only loop over the length ofÂ `part`, rather than the entire stringÂ `s`.

To implement this, we can loop over each character ofÂ `s`Â and add it to the stack. As we add characters, we constantly check if the most recent portion of the stack matches the substringÂ `part`. If it does, we remove those characters from the stack. This approach avoids scanning the entire string repeatedly and only focuses on the portions ofÂ `s`Â that could potentially containÂ `part`.

However, if at any point the characters donâ€™t match, it means that the stack doesnâ€™t containÂ `part`Â at the top. In that case, any intermediate pops made during the check need to be undone, so the characters are pushed back onto the stack in the correct order. The process continues for the rest of the string.

When we finish processing all the characters inÂ `s`, the stack will contain the modified version ofÂ `s`Â with all occurrences ofÂ `part`Â removed. At this point, the stackâ€™s contents are reversed compared to the original string, so we reverse them back to produce the final result, which is then returned.

> For a more comprehensive understanding of stacks, check out theÂ [Stack Explore Card ğŸ”—](https://leetcode.com/explore/learn/card/queue-stack/). This resource provides an in-depth look at stacks, explaining their key concepts and applications with a variety of problems to solidify understanding of the pattern.

#### Algorithm

- Initialize a stack of charactersÂ `stk`Â to store the characters of the string as they are processed.
- Calculate the lengths of the input stringÂ `s`Â and the substringÂ `part`, storing them inÂ `strLength`Â andÂ `partLength`, respectively.
- Use aÂ `for`Â loop to iterate through each character in the stringÂ `s`, starting from indexÂ `0`Â and ending atÂ `strLength - 1`.
    - Push the current character of the string onto the stack.
    - Check if the size of the stack is greater than or equal toÂ `partLength`. If so:
        - Use the helper methodÂ `checkMatch`Â to check if the top of the stack matchesÂ `part`:
            - If a match is found, pop the topÂ `partLength`Â characters from the stack.
- After processing the entire string, initialize a stringÂ `result`Â to construct the resulting string.
- While the stack is not empty, pop each character from the stack and append it to theÂ `result`.
- Reverse the order ofÂ `result`Â to correct the sequence of characters and return it.

Helper methodÂ `checkMatch(stk, part, partLength)`:

- Initialize a temporary stackÂ `temp`Â and copy all characters from the original stackÂ `stk`Â intoÂ `temp`.
- Use aÂ `for`Â loop to iterate overÂ `part`Â in reverse order, starting from indexÂ `partLength - 1`Â and ending atÂ `0`. For each character:
    - Compare the current character ofÂ `part`Â with the top character ofÂ `temp`:
        - If they do not match, returnÂ `false`.
        - Else, remove the top character fromÂ `temp`.
- If all characters ofÂ `part`Â match the top characters of the stack in reverse order, returnÂ `true`.

#### Implementation

```python
class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        stack = []
        part_length = len(part)

        # Iterate through each character in the string
        for char in s:
            # Push current character to stack
            stack.append(char)

            # If stack size is greater than or equal to the part length, check for match
            if len(stack) >= part_length and self._check_match(
                stack, part, part_length
            ):
                # Pop the characters matching 'part' from the stack
                for _ in range(part_length):
                    stack.pop()

        # Convert stack to string with correct order
        return "".join(stack)

    # Helper function to check if the top of the stack matches the 'part'
    def _check_match(self, stack: list, part: str, part_length: int) -> bool:
        # Compare the top 'part_length' elements of the stack with 'part'
        return "".join(stack[-part_length:]) == part
```

#### Complexity Analysis

LetÂ nÂ be the length of the stringÂ `s`, andÂ mÂ be the length of the substringÂ `part`.

- Time complexity:Â O(nâ‹…m)
    
    The algorithm iterates through each character of the stringÂ `s`, contributingÂ O(n)Â to the complexity. For each character pushed onto the stack, the algorithm checks if the topÂ mÂ characters of the stack matchÂ `part`. This involves anÂ O(m)Â comparison for potential matches. Since this check can occur for each character inÂ `s`, the worst-case time complexity isÂ O(nâ‹…m).
    
- Space complexity:Â O(n+m)
    
    The stack stores up toÂ O(n)Â characters in the worst case (e.g., when noÂ `part`Â substrings are removed). The temporary stackÂ `temp`Â in theÂ `checkMatch`Â function also requiresÂ O(n)Â space. Additionally, theÂ `potentialMatch`Â string temporarily stores up toÂ O(m)Â characters during each iteration. So, the total space complexity isÂ O(n)Â (stacks) +Â O(m)Â (temporaryÂ `potentialMatch`), which simplifies toÂ O(n+m).
    

---

### <font color=00CED1>Approach 3: Knuth-Morris-Pratt (KMP) Algorithm</font>
- [ ] Implemented
#### Intuition

So far, we have relied on a naive approach for pattern matching, where we slide the pattern (`part`) over the string (`s`) one character at a time and check for a match. For example, ifÂ `s = "ABABDABACDABABCABAB"`Â andÂ `part = "ABABCABAB"`, the naive approach comparesÂ `part`Â with every substring ofÂ `s`Â of the same length, often rechecking characters unnecessarily. Consider the scenario where the first four characters,Â `"ABAB"`, match, but a mismatch occurs with the fifth character. In the naive approach, the pattern is shifted by just one character, and the comparison restarts from the beginning ofÂ `part`, recheckingÂ `"BAB"`Â again. This results in redundant comparisons and inefficiency.

The Knuth-Morris-Pratt (KMP) algorithm optimizes this by using a longest prefix-suffix (LPS) array for the pattern. The LPS array helps determine how much of the pattern has been matched so far, allowing the algorithm to skip redundant comparisons. When a mismatch happens, instead of starting over from the beginning, we use the LPS array to shift the pattern by an appropriate amount.

For example, if weâ€™ve matchedÂ `"ABABC"`Â but encounter a mismatch at the 6th character, the LPS value forÂ `"ABABC"`Â is 1. We then shift the pattern by 4 characters (5 â€“ 1) and continue matching. This avoids rechecking parts of the pattern weâ€™ve already matched.

For example, consider the patternÂ `part = "ABABCABAB"`. Let's see how we build up the LPS array in the slideshow below:


The LPS array allows the KMP algorithm to skip unnecessary comparisons when a mismatch occurs. When a mismatch happens, instead of starting over from the beginning of the pattern, the algorithm uses the LPS array to determine how much of the pattern has already been matched. It then shifts the pattern by an appropriate amount and continues matching.

For example, letâ€™s say weâ€™re matchingÂ `part = "ABABCABAB"`Â againstÂ `s = "ABABDABACDABABCABAB"`. Suppose weâ€™ve matched the first 4 characters (`"ABAB"`) but encounter a mismatch at the 5th character. The LPS value for the prefixÂ `"ABAB"`Â isÂ `2`, so we know that the first 2 characters of the pattern are already matched. Instead of starting over, we shift the pattern by 2 characters (length of the matched prefix minus the LPS value:Â `4 - 2 = 2`) and continue matching. This skipping of unnecessary comparisons makes the KMP algorithm much more efficient.

The LPS array is built using a linear iterative approach. We initialize two pointers:Â `current`Â (to traverseÂ `part`) andÂ `prefixLength`Â (to track the length of the matching prefix-suffix). We then iterate through the pattern:

- If the characters at current andÂ `prefixLength`Â match, we increment both pointers and setÂ `lps[current] = prefixLength`.
- If they donâ€™t match andÂ `prefixLength`Â is not zero, we backtrackÂ `prefixLength`Â toÂ `lps[prefixLength - 1]`.
- If they donâ€™t match andÂ `prefixLength`Â is zero, we setÂ `lps[current] = 0`Â and incrementÂ `current`.


Finally, we process each character ofÂ `s`Â while using the LPS array to track how much ofÂ `part`Â has been matched. We iterate overÂ `s`Â and when a complete match is found, we remove the matched substring from the stack. If a mismatch occurs, we use the LPS array to backtrack and continue matching.

After processing all characters ofÂ `s`, the stack contains the characters ofÂ `s`Â with all occurrences of part removed. We convert the stack into a string by popping characters and reversing theÂ `result`Â (since stacks are last-in-first-out). We return thisÂ `result`Â as our answer.

#### Algorithm

- Call the helper methodÂ `computeLongestPrefixSuffix`Â with the substringÂ `part`Â to calculate the Longest Prefix Suffix (LPS) array.
- Create a stackÂ `charStack`Â to store characters of the stringÂ `s`Â as they are processed.
- Declare an arrayÂ `patternIndexes`Â of sizeÂ `s.length() + 1`Â to keep track of the pattern index for each character in the stack.
- Use aÂ `for`Â loop to iterate through each character in the stringÂ `s`. Also, maintain a variableÂ `patternIndex`Â to track the current position in the substringÂ `part`.
    - Push the current character onto the stack.
    - If the current character matches the character atÂ `patternIndex`Â inÂ `part`:
        - IncrementÂ `patternIndex`Â and store it inÂ `patternIndexes[charStack.size()]`.
        - IfÂ `patternIndex`Â equals the length ofÂ `part`, the pattern is fully matched:
            - PopÂ `part.length()`Â characters from the stack to remove the matched pattern.
            - ResetÂ `patternIndex`Â toÂ `patternIndexes[charStack.size()]`Â if the stack is not empty, otherwise set it toÂ `0`.
    - If the current character does not match the character atÂ `patternIndex`Â inÂ `part`:
        - IfÂ `patternIndex`Â is not 0, backtrack by settingÂ `patternIndex`Â toÂ `lps[patternIndex - 1]`Â and decrementÂ `strIndex`Â to reprocess the current character.
        - IfÂ `patternIndex`Â is 0, setÂ `patternIndexes[charStack.size()]`Â toÂ `0`.
- InitializeÂ `result`Â to construct the result string from the remaining characters in the stack.
- Reverse the constructed string and return it as the output.

Helper methodÂ `computeLongestPrefixSuffix(pattern)`

- Create an arrayÂ `lps`Â of size equal to the length of the patternÂ `part`Â to store the lengths of the longest proper prefix which is also a suffix.
- Use aÂ `for`Â loop to traverse the patternÂ `part`Â starting from indexÂ `1`. Maintain a variableÂ `prefixLength`Â to track the length of the longest prefix-suffix.
    - If the character at the current position matches the character atÂ `prefixLength`:
        - IncrementÂ `prefixLength`Â and store it inÂ `lps[current]`.
        - Proceed to the next character.
    - Else if the characters do not match andÂ `prefixLength`Â is non-zero:
        - Backtrack to the previous longest prefix-suffix using the LPS array.
    - If no match is found andÂ `prefixLength`Â is zero, setÂ `lps[current]`Â to zero and proceed to the next character.
- Return the fully constructedÂ `lps`Â array.

#### Implementation
```python
class Solution:
    def removeOccurrences(self, s: str, part: str) -> str:
        # Precompute KMP longest prefix-suffix array for the pattern
        kmp_lps = self._compute_longest_prefix_suffix(part)

        # Using list as a stack to track characters and support pattern matching
        char_stack = []

        # Array to store pattern matching indices during traversal
        pattern_indexes = [0] * (len(s) + 1)

        str_index = 0
        pattern_index = 0
        while str_index < len(s):
            current_char = s[str_index]
            char_stack.append(current_char)

            if current_char == part[pattern_index]:
                # Track the next pattern index when characters match
                pattern_indexes[len(char_stack)] = pattern_index + 1
                pattern_index += 1

                if pattern_index == len(part):
                    # Remove entire matched pattern from stack
                    for _ in range(len(part)):
                        char_stack.pop()

                    # Restore pattern index for next potential match
                    pattern_index = (
                        0
                        if not char_stack
                        else pattern_indexes[len(char_stack)]
                    )
            else:
                if pattern_index != 0:
                    # Backtrack pattern matching using KMP LPS
                    str_index -= 1
                    pattern_index = kmp_lps[pattern_index - 1]
                    char_stack.pop()
                else:
                    # Reset pattern index tracking when no match is possible
                    pattern_indexes[len(char_stack)] = 0

            str_index += 1

        # Convert remaining stack characters to result string
        return "".join(char_stack)

    def _compute_longest_prefix_suffix(self, pattern: str) -> list:
        # Array to store the longest proper prefix which is also a suffix
        lps = [0] * len(pattern)

        # Initialize tracking variables for prefix and current position
        current = 1
        prefix_length = 0
        while current < len(pattern):
            # If characters match, extend the prefix length
            if pattern[current] == pattern[prefix_length]:
                # Store the length of matching prefix
                prefix_length += 1
                lps[current] = prefix_length
                current += 1

            # If characters don't match and we're not at the start of the pattern
            elif prefix_length != 0:
                # Backtrack to the previous longest prefix-suffix
                prefix_length = lps[prefix_length - 1]

            # If no match and no prefix to backtrack
            else:
                # No prefix-suffix match found
                lps[current] = 0
                current += 1

        # Return the computed longest prefix-suffix array
        return lps
```

#### Complexity Analysis

LetÂ nÂ be the length of the stringÂ `s`, andÂ mÂ be the length of the substringÂ `part`.

- Time complexity:Â O(n+m)Â for Java and Python3,Â O(n2+m)Â for C++
    
    The algorithm consists of two main components: the preprocessing step to compute the KMP longest prefix-suffix (`lps`) array and the traversal of the stringÂ `s`.
    
    The preprocessing step takesÂ O(m)Â time, as theÂ `lps`Â array is computed for the patternÂ `part`.
    
    The traversal ofÂ `s`Â uses a stack and performs efficient pattern matching with the help of theÂ `lps`Â array. Each character inÂ `s`Â is processed once, and backtracking in the pattern matching is guided by theÂ `lps`Â array, ensuring that each character is examined only a constant number of times. Thus, the traversal takesÂ O(n)Â time.
    
    Combining these two components, the overall time complexity isÂ O(n+m).
    
    However, the result construction step in the C++ solution has a time complexity ofÂ O(n2)Â due to repeated string modifications. As a result, the overall time complexity of the C++ solution becomesÂ O(n2+m).
    
- Space complexity:Â O(n+m)
    
    The primary space usage comes from the stack, which can store up toÂ nÂ characters in the worst case if no matches are removed. Additionally, the pattern matching indices array requiresÂ O(n)Â space, and theÂ `lps`Â array used for KMP preprocessing requiresÂ O(m)Â space. These components together result in a total space complexity ofÂ O(n+m).







## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```











