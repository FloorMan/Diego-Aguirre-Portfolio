---
title: Generate Parentheses
difficulty: Medium
topics:
  - String
  - DynamicProgramming
  - Backtracking
  - DFS
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - Recursion
date: 2025-03-07
time: 25:00
leetcode_id: 22
solved: true
review: true
---
[[LeetCode]]
[[Recursion]]
## [Problem](https://leetcode.com/problems/generate-parentheses/description/)
Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.

**Example 1:**

**Input:** n = 3
**Output:** ["((()))","(()())","(())()","()(())","()()()"]

**Example 2:**

**Input:** n = 1
**Output:** ["()"]

**Constraints:**
- `1 <= n <= 8`
## My Approach
### Time: O($2^{\text{n}}$)
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def dfs (left, right, s):
            if len(s) == n * 2:
                result.append(s)
                return
            if left < n:
                dfs(left + 1, right, s + '(')
            if right < left:
                dfs(left, right + 1, s + ')')
  
        result = []
        dfs(0,0,'')
        return result
```
Here, we go through a recursive depth-first-search to find our correct permutations. We check if we can add a left parenthesis if we still haven’t hit `n` left parentheses. We can then perform another option of adding a right parenthesis if our right parentheses count is less than the left parentheses. This means we still have some open parentheses. 

There is also another option of iterating through all the combinations. We start with the case of `n = k`, and then append all of the `n = k - 1` to  $[n_{k-1} ( ), (n_{k-1}), ()n_{k-1}]$ and removing any collisions, possibly by using a set.     


---
## Solution



---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```