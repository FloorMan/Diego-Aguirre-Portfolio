---
title: Word Break
difficulty: Medium
topics:
  - array
  - Hash Table
  - String
  - DynamicProgramming
  - trie
  - Memoization
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-09-17
time: 23:08
leetcode_id: 139
solved: true
review: false
---
[[LeetCode]]
[[SWE Prep]]
[[Dynamic Programming]]
## [Problem](https://leetcode.com/problems/word-break/description/)
Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note** that the same word in the dictionary may be reused multiple times in the segmentation.

**Example 1:**

**Input:** s = "leetcode", wordDict = ["leet","code"]
**Output:** true
**Explanation:** Return true because "leetcode" can be segmented as "leet code".

**Example 2:**

**Input:** s = "applepenapple", wordDict = ["apple","pen"]
**Output:** true
**Explanation:** Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.

**Example 3:**

**Input:** s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
**Output:** false

**Constraints:**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` and `wordDict[i]` consist of only lowercase English letters.
- All the strings of `wordDict` are **unique**.


## My Approach
### Time: O($n^2 + m \cdot k$)
In my approach, I chose to build a trie to store all of the words in the dictionary. We store each word wit ha flag indicating if it is a complete word or part of a word.
Then, we set up a dynamic programming array the same length as the string, but filled with `False` to iterate over. This array tells us if the `i` index of the array can be built using words from the dictionary. 

The basic logic is that we go through each letter of the string. We start from the root of our trie, and if the letter is found within the trie, we check if it has the word flag. If it does, we set the `i` index of the dp array to `True`, and move on to the next layer. If it does not, we move on. We do this until we reach a letter not found in the current nodes children. If this happens, we go back to the root of the trie and check the `i - 1` index to see if it was true. If it was, then we know that up until now, we were able to build the string. If not, then we know that there is no possible way to build the string using dictionary words, and so we move on. 

We do this until we reach the end of the string. If the last index of the dp array is `True`, we know that it is possible to build the string, and so we return `True`

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isWord = False
  
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        self.root = TrieNode()
  
        for word in wordDict:
            currNode = self.root
            for char in word:
                if char not in currNode.children:
                    currNode.children[char] = TrieNode()
                currNode = currNode.children[char]
            currNode.isWord = True
        dp = [False] * len(s)
        for i in range(len(s)):
            if i == 0 or dp[i-1]:
                currNode = self.root
  
                for j in range (i, len(s)):
                    if s[j] not in currNode.children:
                        break
                    currNode = currNode.children[s[j]]
                    if currNode.isWord:
                        dp[j] = True

        return dp[-1]
```




---
## [Solution](https://leetcode.com/problems/word-break/editorial)




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```