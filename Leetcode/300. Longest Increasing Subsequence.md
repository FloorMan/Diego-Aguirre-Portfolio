---
title: Longest Increasing Subsequence
difficulty: Medium
topics:
  - array
  - Binary Search
  - DynamicProgramming
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-09-24
time: 17:03
leetcode_id: 300
solved: true
review: true
---
[[LeetCode]]
[[SWE Prep]]
[[Dynamic Programming]]
## [Problem](https://leetcode.com/problems/longest-increasing-subsequence/description/)
Given an integer array `nums`, return _the length of the longest **strictly increasing subsequence**_.

**Example 1:**

**Input:** nums = [10,9,2,5,3,7,101,18]
**Output:** 4
**Explanation:** The longest increasing subsequence is [2,3,7,101], therefore the length is 4.

**Example 2:**

**Input:** nums = [0,1,0,3,2,3]
**Output:** 4

**Example 3:**

**Input:** nums = [7,7,7,7,7,7,7]
**Output:** 1

**Constraints:**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

**Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?


## My Approach
### Time: $O(n^2)$

Here, we set up a dynamic programming array to hold the longest substring encountered so far. Instead of going from left to right, we start at the end, since the longest possible substring at the end is itself (1).

Then, we iterate backwards through the array, checking to see if any number that comes after is larger, and if it is, then we add 1 to the max substring count contained in our dp array. Then, we take the max of all the counts we found for our new value. This is the longest substring found at index i:

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        longest = 1
        
        dp = [1] * len(nums)

        for i in range(len(nums) - 2, -1, -1):
            longestSub = 1
            for j in range(i + 1, len(nums)):
                if nums[i] < nums[j]:
                    longestSub = max(longestSub, dp[j] + 1)
            dp[i] = longestSub
            longest = max(longest, longestSub)
        return longest
```


There is also the faster alternate solution of creating a directed graph (sort of). If you make an array, we can use binary search to find out where to place the next value. If the left pointer of the binary search is all the way to the right (i.e. the index is the length of the array), then we know that our value is bigger than all the others, so we should add it to our array. If it’s anywhere else, we should replace the value in that spot (meaning it’s either the smallest, or in between two numbers. In either case, we want to replace that number with the smaller number, giving us a better opportunity to find a longer subsequence).

This size of this array will give us the solution we are looking for, in only an $O(n \log n)$ time

```python
def binarySearch(arr, targetVal):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == targetVal:
            return mid
        if arr[mid] < targetVal:
            left = mid + 1
        else:
            right = mid - 1
    return left   # returns the lower bound (first >= targetVal)

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        piles = []

        for num in nums:
            index = binarySearch(piles, num)

            if index == len(piles):
                piles.append(num)
            else:
                piles[index] = num
        return len(piles)

```



---
## [Solution](https://www.youtube.com/watch?v=0wT67DOzqBg)




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```