---
title: Smallest Missing Non-Negative Integer after Operations
difficulty: Medium
topics:
  - array
  - Hash Table
  - Greedy
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-10-16
time: 22:00
leetcode_id: 2598
solved: true
review: true
---
[[LeetCode]]

## [Problem](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/description/?envType=daily-question&envId=2025-10-16)
You are given a **0-indexed** integer array `nums` and an integer `value`.

In one operation, you can add or subtract `value` from any element of `nums`.

- For example, if `nums = [1,2,3]` and `value = 2`, you can choose to subtract `value` from `nums[0]` to make `nums = [-1,2,3]`.

The MEX (minimum excluded) of an array is the smallest missing **non-negative** integer in it.

- For example, the MEX of `[-1,2,3]` is `0` while the MEX of `[1,0,3]` is `2`.

Return _the maximum MEX of_ `nums` _after applying the mentioned operation **any number of times**_.

**Example 1:**

**Input:** nums = [1,-10,7,13,6,8], value = 5
**Output:** 4
**Explanation:** One can achieve this result by applying the following operations:
- Add value to nums[1] twice to make nums = [1,**0**,7,13,6,8]
- Subtract value from nums[2] once to make nums = [1,0,**2**,13,6,8]
- Subtract value from nums[3] twice to make nums = [1,0,2,**3**,6,8]
The MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.

**Example 2:**

**Input:** nums = [1,-10,7,13,6,8], value = 7
**Output:** 2
**Explanation:** One can achieve this result by applying the following operation:
- subtract value from nums[2] once to make nums = [1,-10,**0**,13,6,8]
The MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.

**Constraints:**

- `1 <= nums.length, value <= 105`
- `-109 <= nums[i] <= 109`


## My Approach
### Time: $O(n)$

This one took me a good second to figure out. I came to the answer rather quickly, but the implementation was a bit scuffed. My first approach was to add the modular residual to a set. If the residual already existed, then we add the residual + value, until it doesnâ€™t exist. Then we go through with a counter to find the first missing one. This one took too long.

My next iteration was to create a dictionary, which holds the number of times an index was accessed. Based on the number of times it was accessed, we can jump all the way to the last index to add our residual value.

```python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        ans = 0
        dp = {}

        for num in nums:
            temp = dp.get(num % value)
            if temp == None:
                dp[num % value] = 1
            else:
                dp[(num % value) + (dp.get(num % value) * value)] = 1
                dp[num % value] += 1
                
        counter = 0
        while True:
            if counter not in dp:
                return counter
            counter += 1

        return ans
```

We can *further* reduce this by just creating an array the size of `value`, and store the amount of times that modular index was accessed. Based on the lowest accessed index, we know that would be the first missing index, so we just multiply our value by that amount and add our residual to get our answer.

```python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        dp = [0] * value

        for num in nums:
            dp[num % value] += 1
        
        leastAccessed = min(dp)
        index = dp.index(leastAccessed)
        
        return (leastAccessed * value) + index
```


---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```