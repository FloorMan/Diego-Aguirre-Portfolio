---
title: Reverse Linked List
difficulty: Easy
topics:
  - Linked Lists
  - Recursion
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-03-11
time: 8:36
leetcode_id: 206
solved: true
review:
---
[[LeetCode]]
[[Linked Lists]]
## [Problem](https://leetcode.com/problems/reverse-linked-list/description/)
Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

**Input:** head = [1,2,3,4,5]
**Output:** [5,4,3,2,1]

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

**Input:** head = [1,2]
**Output:** [2,1]

**Example 3:**

**Input:** head = []
**Output:** []

**Constraints:**

- The number of nodes in the list is the range `[0, 5000]`.
- `-5000 <= Node.val <= 5000`

**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?


## My Approach
### Time: O(n)
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Initialize our pointers
        prev = None
        curr = head
  
        while curr is not None:
            # We kno that there is another value after, so we have to reverse the direction
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
  
        return prev
```
Simple enough. We start with two pointers, one for the previous node and one for our current node. As we go through the list, we make sure to set the direction of our current node to the one before and then move all of our pointers forward once.


Here is also the recursive solution:
```python
class Solution:
    def recursive(self, prev, current):
        if current.next is None: # Base case of empty or just 1
            current.next = prev
            return current
  
        head = self.recursive(current, current.next)
        current.next = prev
        return head
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return head
        return self.recursive(None, head)
```
We perform a DFS through the list until we reach our base case of the end. Then we just set our next pointer to the previous node we passed as we go back up the list.

---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```