---
title: Lowest Common Ancestor of a Binary Search Tree
difficulty: Medium
topics:
  - Tree
  - DFS
  - BFS
  - Binary Tree
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - Trees
  - BinaryTrees
  - DFS
date: 2025-03-27
time: 20:28
leetcode_id: 235
solved: true
review: true
---
[[LeetCode]]
[[Trees]]
## [Problem](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
**Output:** 6
**Explanation:** The LCA of nodes 2 and 8 is 6.

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

**Input:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
**Output:** 2
**Explanation:** The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

**Example 3:**

**Input:** root = [2,1], p = 2, q = 1
**Output:** 2

**Constraints:**

- The number of nodes in the tree is in the range `[2, 105]`.
- `-109 <= Node.val <= 109`
- All `Node.val` are **unique**.
- `p != q`
- `p` and `q` will exist in the BST.


## My Approach
### Time: 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
  
class Solution:
    def lowestCommonAncesor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        curr = root
  
        while curr:
            if p.val <= curr.val and q.al >= curr.val or p.val >= curr.val and q.val <= curr.val: # Middle
                return curr
           elif curr.val < p.val and curr.val < q.val: # On the left side
                curr = curr.right
            elif curr.val > p.val and curr.val > q.val: #On the right side
                curr = curr.left
        return curr
```
Should not have taken me so long, I forgot that it was a BST. This allows us to search based on the value of P and Q. There are three cases:
1. Our root value is sitting between P and Q (inclusive)
	1. If we are between, we know that P and Q have to be on two different branches, therefore, our root node must be the shortest link between the two.
	2. This also means that if our node is P or Q, we must have navigated to the shortest link.
2. Our root value is less than both P and Q
	1. Both our values must lie to the right of our current node, so we navigate to the right
3. Our root value is greater than both P and Q
	1. Both our values must be on the left, so we navigate to the left.
We do this iteratively (or recursively) until we reach our shortest ancestral node 





---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```