---
title: Construct Smallest Number From DI String
difficulty: Medium
topics:
  - String
  - Backtracking
  - Stacks
  - Greedy
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - daily
date: 2025-02-18
time: 25:59
leetcode_id: 2375
solved: true
---
[[LeetCode]]
[Problem Link](https://leetcode.com/problems/construct-smallest-number-from-di-string/description/?envType=daily-question&envId=2025-02-18)


## Problem
You are given a **0-indexed** string `pattern` of length `n` consisting of the characters `'I'` meaning **increasing** and `'D'` meaning **decreasing**.

A **0-indexed** string `num` of length `n + 1` is created using the following conditions:

- `num` consists of the digits `'1'` to `'9'`, where each digit is used **at most** once.
- If `pattern[i] == 'I'`, then `num[i] < num[i + 1]`.
- If `pattern[i] == 'D'`, then `num[i] > num[i + 1]`.

Return _the lexicographically **smallest** possible string_ `num` _that meets the conditions._

**Example 1:**

**Input:** pattern = "IIIDIDDD"
**Output:** "123549876"
**Explanation:**
At indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].
At indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].
Some possible values of num are "245639871", "135749862", and "123849765".
It can be proven that "123549876" is the smallest possible num that meets the conditions.
Note that "123414321" is not possible because the digit '1' is used more than once.

**Example 2:**

**Input:** pattern = "DDD"
**Output:** "4321"
**Explanation:**
Some possible values of num are "9876", "7321", and "8742".
It can be proven that "4321" is the smallest possible num that meets the conditions.

**Constraints:**

- `1 <= pattern.length <= 8`
- `pattern` consists of only the letters `'I'` and `'D'`.

## Thoughts
Easy problem, some of the solutions are really interesting and indepth. A little complicated.

## My Approach
### Time: 25:59

We want to represent the digits used as an array of length 9 (9 digits). [0,0,0,0,0,0,0,0,0]
When a digit is used, the space in the array is marked with the smallest location it can go.
We want the biggest numbers in the back, and the smallest in the front. So we’ll go back to front.
We can actually treat this as a swap, where I indicates moving to the next number, and D indicates swapping with the next number. IIIIDID: [1,2,3,4,5,6,7,8,9] → [1,2,3,4,6,5,8,7,9]

This almost works, but we need to handle the case of multiple decrements. This means we keep swapping, like bubble sort, until we have the correct solution. With our current solution, we only look at the current pair and don’t consider multiple decrements.
									IIDDDI → [1,2,4,5,6,3,7]

In this case, we store the amount of D’s we encounter in a row, and set it back to 0 when we encounter an I. We perform the swap for the amount of D’s we have:
								IIDDDI → [1,2,6,5,4,3,7]

```python
class Solution:
    def smallestNumber(self, pattern: str) -> str:
        positionArray = ["1",'2','3','4','5','6','7','8','9']
        numDecr = 0

        for letter in range(len(pattern)):
            if pattern[letter] == 'D':
                numDecr += 1
                for i in range(numDecr):
                    temp = positionArray[letter - i]
                    positionArray[letter - i] = positionArray[letter - i + 1]
                    positionArray[letter - i + 1] = temp
            else:
                numDecr = 0
        return "".join(positionArray[:len(pattern) + 1])
```
---
## Solution

### Approach 4: Using Stack

#### Intuition

The problems that are solved via recursion can almost always be solved using a stack as well. The reason is that recursion inherently uses a call stack to keep track of function calls, storing the current state before diving deeper into the problem. Each recursive call pushes a new frame onto the call stack, which holds the function’s local variables and execution context. When the base case is reached, the function calls start returning, effectively unwinding the stack in a last-in, first-out (LIFO) manner.

In this case, the core idea is to use a stack to manage the order in which numbers are appended. The stack helps handle consecutive`'D'`characters efficiently by delaying their placement, ensuring that numbers in a decreasing sequence are correctly placed in the smallest lexicographical order.

More specifically, we iterate through the pattern while pushing numbers onto the stack. Every time we see a`'D'`, we push the current number onto the stack and continue, delaying its placement in the result. This is because a`'D'`means the next number should be smaller than the current one, so we must delay placing the numbers to ensure that they appear in decreasing order when finally appended.

When we encounter an`'I'`or reach the end of the pattern, we know that all numbers stored in the stack must now be placed in the result to maintain the correct order. At this point, we start popping from the stack, appending each number to the result before moving forward. This guarantees that any numbers stored due to a sequence of`'D'`characters appear in descending order, ensuring the smallest valid number.

For example, given the pattern`"IDID"`, we start by pushing`1`onto the stack because we always push the next number. Since the first character is`'I'`, we immediately pop from the stack and append`1`to the result. Then we push`2`and, seeing the next`'D'`, we push`3`instead of immediately appending. The`'I'`that follows tells us it's time to pop and append the numbers, so`3`and then`2`are added to the result, maintaining the required decreasing order. The process continues in this manner, ensuring that the number we build respects the pattern while remaining lexicographically smallest.

#### Algorithm

- Initialize an empty string`result`to store the final smallest number.
    
- Use a`stack`named`numStack`to manage digits based on the pattern.
    
- Iterate through the`pattern`:
    
    - Push`index + 1`onto`numStack`, ensuring numbers are pushed in increasing order.
    - If at the end of the pattern or the current character is`'I'`:
        - Pop all elements from`numStack`and append them to`result`, ensuring that decreasing sequences are handled before moving to the next increasing sequence.
- Return`result`as the smallest number following the given pattern.
    

#### Implementation

#### Complexity Analysis

Letnbe the length of the input string`pattern`.

- Time complexity:O(n)
    
    We iterate through the`pattern`string once, processing each character exactly once. In each iteration, we push at most one number onto the stack, contributingO(n)operations in total. Additionally, whenever we encounter`'I'`or reach the end, we pop all elements from the stack. Since each number is pushed and popped exactly once, this also contributesO(n). Therefore, the overall time complexity isO(n).
    
- Space complexity:O(n)
    
    The extra space usage comes from the`stack`, which, in the worst case, holds all numbers from1ton+1. This happens when the entire`pattern`consists of`'D'`characters, causing all numbers to be pushed before any are popped. Thus, the worst-case space complexity isO(n).
    

---

### Approach 5: Greedy Approach with Sliding Window Reversal

#### Intuition

A more structured approach to constructing the smallest number that fits the given pattern is to use a**greedy strategy with a sliding window reversal technique**. Instead of constructing the number from scratch, we begin with a baseline sequence of consecutive numbers (e.g.,`123456789`for a pattern of length`n`). This ensures that we always start with the smallest possible number and then modify it as needed to satisfy the given pattern.

The idea is to use two pointers:`currentIndex`, which traverses the pattern, and`previousIndex`, which marks the start of the segment that needs to be reversed after we encounter a`'D'`(Decreasing) character. Whenever we find an`'I'`(Increasing) or reach the end of the pattern, we reverse the segment between`previousIndex`and`currentIndex`to ensure that the digits follow the required decreasing order.

For each character in the pattern:

- If the current character is`'I'`, no modification is required because the sequence already maintains increasing order.
- If the current character is`'D'`, we continue moving until we find an`'I'`or reach the end of the pattern. Once we find an`'I'`or exhaust the pattern, we reverse the substring from`previousIndex`to`currentIndex`to create the required decreasing order.

Consider an example where the pattern is`"DDI"`:

1. We initialize our sequence as`"1234"`, since the pattern length is 3.
2. The first character is`'D'`, so we continue scanning until we reach an`'I'`. Once we reach the`'I'`, we reverse the first three elements (`"123" → "321"`).
3. Since the final character is`'I'`, no further modifications are needed, and we append the last digit as is.
4. The final result is`"3214"`.

#### Algorithm

- Initialize a string called`result`to store the final result.
    
- Iterate through the`pattern`:
    
    - Use`currentIndex`to traverse the pattern and`previousIndex`to mark the start of the substring that may need to be reversed.
        
    - Append the value`1 + currentIndex`to`result`.
        
    - When necessary, reverse the substring starting from`previousIndex`:
        
        - If`currentIndex`reaches the end of the pattern or the current character in the pattern is`'I'`:
            - Create a temporary string (`temp`) and reverse the substring starting from`previousIndex`to`currentIndex`.
            - Update`result`by concatenating the part before`previousIndex`and the reversed substring from`previousIndex`onward.
            - Update`previousIndex`to`currentIndex + 1`.
- Return the final`result`as a string.
    

#### Implementation

#### Complexity Analysis

Letnbe the length of the input string`pattern`.

- Time complexity:O(n2)
    
    The algorithm iterates through the input string`pattern`once, which takesO(n)time. However, during each iteration, when the character is 'I' or the end of the string is reached, the algorithm reverses a substring of the`result`string. Reversing a substring using extra string takesO(k)time, wherekis the length of the substring. In the worst case, this substring can be of sizeO(n), and this operation can happen up toO(n)times.
    
    Therefore, the overall time complexity is dominated by the substring reversal operations, resulting inO(n2).
    
- Space complexity:O(n)
    
    The algorithm uses an extra string`result`to store the intermediate and final result, which grows linearly with the input size, requiringO(n)space. Additionally, a temporary extra string named`temp`is used during substring reversal, which also requiresO(n)space.
    
    Apart from these, the algorithm uses a few auxiliary variables like`currentIndex`and`previousIndex`, which occupy constant space. Thus, the dominant space usage comes from the extra strings, making the overall space complexityO(n).
    

---

### Approach 6: Optimized Greedy Approach with Precomputed 'D' Segments

#### Intuition

The previous approach used a sliding window reversal to handle decreasing sequences efficiently. An alternate strategy would involve precomputing the number of consecutive`'D'`s at each position. This allows us to directly determine the correct digit placement without the need for explicit reversal operations.

Instead of modifying an existing sequence as we traverse the pattern, we first scan the pattern**backward**to compute an array`arrD[i]`, where each entry represents the number of consecutive`'D'`s that appear after the corresponding position. This precomputed information allows us to determine the exact digit that should be placed in each position without needing to reverse segments manually.

As we build the answer, we maintain two key values:

1. `maxSoFar`: The largest number assigned so far.
2. `currMax`: A helper variable to ensure that subsequent digits are placed in proper increasing order, preventing conflicts between previously placed numbers.

When encountering an`'I'`, we simply assign the smallest available number, which is`maxSoFar + 1`. However, when encountering a`'D'`, we need to ensure that the digits form a descending order. To achieve this, we use`arrD[i]`to determine how far the descending sequence extends. Instead of constructing the decreasing sequence step by step, we calculate the correct number directly:

digit=1+maxSoFar+arrD[i]

This formula ensures that:

- The assigned number is large enough to maintain the required descending order.
- The sequence remains lexicographically minimal by assigning the smallest possible numbers that satisfy the constraints.

The algorithm is visualized below:

![Current](blob:https://leetcode.com/8b2a5eee-2cad-4695-ba02-f0d1bdd8f682)

11 / 11

#### Algorithm

- Initialize`patternLength`to the length of the input`pattern`.
    
- Initialize`maxSoFar`and`currMax`to 0, which will keep track of the largest digits used so far.
    
- Initialize a vector`arrD`of size`patternLength + 1`to store the lengths of decreasing subsequences in the pattern.
    
- Calculate the lengths of decreasing subsequences in the pattern:
    
    - Iterate backward through the`pattern`:
        - If the current character is`'D'`, calculate the length of the decreasing subsequence starting from the current index as`arrD[patternIndex + 1] + 1`.
- Initialize an empty string`result`to build the final result.
    
- Build the result string based on the pattern:
    
    - Iterate through each position in the pattern:
        - If the current character is`'I'`, increment`maxSoFar`, append it to`result`, and update`maxSoFar`, as the maximum of its current value and`currMax`.
        - If the current character is`'D'`, calculate the appropriate digit from`maxSoFar`and`arrD[position]`, append it to`result`, and update`currMax`.
- Return the`result`, which represents the smallest number satisfying the pattern.
    

#### Implementation

#### Complexity Analysis

Letnbe the length of the input string`pattern`.

- Time complexity:O(n)
    
    The algorithm processes the input string`pattern`in two main steps. First, it performs a backward traversal to compute the lengths of decreasing subsequences. This step iterates through the string once, takingO(n)time. Second, it performs a forward traversal to construct the result string based on the computed subsequence lengths. This step also iterates through the string once, takingO(n)time. Since both steps are linear and independent, the overall time complexity isO(n).
    
    Additionally, the use of built-in functions and string concatenation (`+=`) does not increase the time complexity beyondO(n), as these operations are either constant time or linear in the context of this algorithm. Thus, the total time complexity remainsO(n).
    
- Space complexity:O(n)
    
    The algorithm uses additional space for two main purposes. First, it stores the lengths of decreasing subsequences in an array`arrD`, which requiresO(n)space. Second, it constructs the result string, which also grows linearly with the input size, requiringO(n)space.
    
    Apart from these, the algorithm uses a few auxiliary variables like`maxSoFar`,`currMax`, and`temp`, which occupy constant space. Therefore, the dominant space usage comes from the array`arrD`and the result string, making the overall space complexityO(n).


---


---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```