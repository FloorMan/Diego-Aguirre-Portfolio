---
title: Find Unique Binary String
difficulty: Medium
topics:
  - array
  - Backtracking
  - Hash Table
  - String
  - trie
  - binary
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - daily
date: 2025-02-19
time: 28:59
leetcode_id: 1980
solved: true
---
[[LeetCode]]

## Problem
[Link to Question](https://leetcode.com/problems/find-unique-binary-string/?envType=daily-question&envId=2025-02-20)

Given an array of strings `nums` containing `n` **unique** binary strings each of length `n`, return _a binary string of length_ `n` _that **does not appear** in_ `nums`_. If there are multiple answers, you may return **any** of them_.

**Example 1:**

**Input:** nums = ["01","10"]
**Output:** "11"
**Explanation:** "11" does not appear in nums. "00" would also be correct.

**Example 2:**

**Input:** nums = ["00","01"]
**Output:** "11"
**Explanation:** "11" does not appear in nums. "10" would also be correct.

**Example 3:**

**Input:** nums = ["111","011","001"]
**Output:** "101"
**Explanation:** "101" does not appear in nums. "000", "010", "100", and "110" would also be correct.

**Constraints:**

- `n == nums.length`
- `1 <= n <= 16`
- `nums[i].length == n`
- `nums[i]` is either `'0'` or `'1'`.
- All the strings of `nums` are **unique**.
## Thoughts
Got distracted halfway through lol. I will go back and implement the trie solution

## My Approach
### Time: 

My initial thought is to throw each string into a hashmap, and then generate progressively the first string that is not found within the hashmap.

Another approach that seems faster is to build a binary tree, with each node representing how many times it’s been passed through. Left would be 0, right would be 1. This would be faster than the hashmap solution, but longer to implement. To find the solution, we would traverse the tree by which side has less pass through’s until we find an unused leaf node.

I ended up going with the set solution just because it was easier to implement. 

```python
class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        numbers = set()
        for num in nums:
            numbers.add(num) # Keep all of the numbers in a set
        length = len(nums[0])
        answer = '0' * length
        while answer in numbers:
            answer = self.fixPadding(bin(int(answer, 2) + 1)[2:], length) 
            print(answer)
        return answer

# This could be replaed by the built in function .zfill(length)
    def fixPadding(self, binaryString, length):   
        missingPadding = length - len(binaryString)
        return ('0' * missingPadding) + binaryString
```




---
## Solution
### Approach 2: Iterate Over Integer Equivalents

**Intuition**

Without the optimization, the previous approach would be reasonable when the length of`nums`is not bounded. However,`nums`has a length of`n`. There are many more possible binary strings than there are strings in`nums`.

In fact, since there are only`n`strings in`nums`, we never need to check more than`n + 1`different binary strings, since at least one of them would not appear in`nums`and thus be a valid answer. How do we decide which`n + 1`binary strings we should check?

Let's start by converting each string in`nums`to its equivalent base-10 integer. We will store these integers in a hash set`integers`. Now, we can simply use a for loop to iterate over the range`[0, n]`(the size of this range is`n + 1`, so it is guaranteed to contain at least one valid answer). For each number, we check if it is in`integers`. If it isn't, it represents a valid answer. We just need to convert it back to a binary string of length`n`and return it.

Note that in some cases, if a valid answer, when converted to a binary string, has a length shorter than`n`, we need to add "0"s to the beginning to make its length equal to`n`.

**Algorithm**

1. Create`integers`, a hash set containing all the elements of`nums`in their base-10 integer form.
2. Initialize`n = nums.length`.
3. Iterate`num`from`0`to`n`:
    - If`num`is not in`integers`, convert it to a binary string of length`n`and return it.
4. The code should never reach this point. Return anything.

**Implementation**

**Complexity Analysis**

Givennas the length of`nums`(and the length of each binary string),

- Time complexity:O(n2)
    
    We iterate overnstrings and convert them to integers, costingO(n)for each integer.
    
    We then iterate`num`in the range`[0, n]`. When we find the answer, we spendO(n)to convert it to a string.
    
- Space complexity:O(n)
    
    The hash set`integers`has a size ofn.
    

  

---

### Approach 3: Random

**Intuition**

As mentioned before, there are many more possible binary strings than there are "banned" binary strings in`nums`.

We can randomly generate binary strings until we find one that is not in`nums`. For`n = 16`, there are216=65536strings we could generate, and only16that would not be valid. Thus, the probability of finding a valid answer is6553665536−16​, over 99.9%.

In general, the probability of generating a valid answer randomly is2n2n−n​. Because2ngrows much faster thann, the probability is very favorable for us.

For ease of implementation, we will start by converting each binary string in`num`to its base-10 equivalent, then storing these integers in a hash set`integers`, just like in approach 2.

Then, we will generate random numbers in the range[0,2n]until we find one not in`integers`. Once we do, we convert it to a binary string of length`n`and return it.

**Algorithm**

1. Create`integers`, a hash set containing all the elements of`nums`in their base-10 integer form.
2. Set`ans`to any value in`integers`and`n = nums.length`.
3. While`ans`is in`integers`:
    - Randomly generate an integer between`0`(inclusive) and2n.
    - Set`ans`to the randomly generated integer.
4. Convert`ans`to a binary string and return it.

**Implementation**

**Complexity Analysis**

Givennas the length of`nums`(and the length of each binary string),

- Time complexity:O(∞)
    
    Technically, the worst-case scenario would see the algorithm running infinitely, always selecting elements in`integers`. However, the probability that the algorithm runs for more than a few steps, let alone infinitely, is so low that we can assume it to be effectively 0. This probability also lowers exponentially as`n`increases.
    
    For`n = 16`, there is an over 99.9% chance that we find an answer on the first iteration. For`n = 20`, we have an over 99.998% chance. Practically, this algorithm runs extremely quickly.
    
- Space complexity:O(n)
    
    The hash set`integers`has a size ofn.
    
    We don't count the answer as part of the space complexity.
    

  

---

### Approach 4: Cantor's Diagonal Argument

**Intuition**

[Cantor's diagonal argument](https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument)is a proof in set theory.

While we do not need to fully understand the proof and its consequences, this approach uses very similar ideas.

We start by initializing the answer`ans`to an empty string. To build`ans`, we need to assign either`"0"`or`"1"`to each index`i`for indices`0`to`n - 1`. How do we assign them so`ans`is guaranteed to be different from every string in`nums`? We know that two strings are different, as long as they differ by at least one character. We can intentionally construct our`ans`based on this fact.

For each index`i`, we will check theithcharacter of theithstring in`nums`. That is, we check`curr = nums[i][i]`. We then assign`ans[i]`to the opposite of`curr`. That is, if`curr = "0"`, we assign`ans[i] = "1"`. If`curr = "1"`, we assign`ans[i] = "0"`.

What is the point of this strategy?`ans`will differ from every string in**at least**one position. More specifically:

- `ans`differs from`nums[0]`in`nums[0][0]`.
- `ans`differs from`nums[1]`in`nums[1][1]`.
- `ans`differs from`nums[2]`in`nums[2][2]`.
- ...
- `ans`differs from`nums[n - 1]`in`nums[n - 1][n - 1]`.

Thus, it is guaranteed that`ans`does not appear in`nums`and is a valid answer.

> This strategy is applicable because both the length of`ans`and the length of each string in`nums`are larger than or equal to`n`, the number of strings in`nums`. Therefore, we can find one unique position for each string in`nums`.

**Algorithm**

1. Initialize the answer`ans`. Note that you should build the answer in an efficient manner according to the programming language you're using.
2. Iterate`i`over the indices of`nums`:
    - Set`curr = nums[i][i]`.
    - If`curr = "0"`, add`"1"`to`ans`. Otherwise, add`"0"`to`ans`.
3. Return`ans`.

**Implementation**

**Complexity Analysis**

Givennas the length of`nums`(and the length of each binary string),

- Time complexity:O(n)
    
    We iterate over each string in`nums`. Assuming the string building is efficient, each iteration costsO(1), and joining the answer string at the end costsO(n).
    
- Space complexity:O(1)
    
    We don't count the answer as part of the space complexity.



---
---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```