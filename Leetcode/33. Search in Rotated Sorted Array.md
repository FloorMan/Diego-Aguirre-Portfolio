---
title: Search in Rotated Sorted Array
difficulty: Medium
topics:
  - array
  - Binary Search
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-02-28
time: 29:52
leetcode_id: 33
solved: true
review: true
---
[[LeetCode]]
[[Arrays]]
## Problem
[Link to Question](leetcode.com/problems/search-in-rotated-sorted-array/)
There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

**Input:** nums = [4,5,6,7,0,1,2], target = 0
**Output:** 4

**Example 2:**

**Input:** nums = [4,5,6,7,0,1,2], target = 3
**Output:** -1

**Example 3:**

**Input:** nums = [1], target = 0
**Output:** -1

**Constraints:**

- `1 <= nums.length <= 5000`
- `-104 <= nums[i] <= 104`
- All values of `nums` are **unique**.
- `nums` is an ascending array that is possibly rotated.
- `-104 <= target <= 104`

## Thoughts


## My Approach
### Time: O(logn)
I went for a recursive approach, but this could just have easily been a two pointer approach. Two pointer would actually have been a much simpler/better approach. Had a bit of a brain fart trying to remember binary search, but that’s what practice is for.
```python
class Solution:
    def middleSearch(self, left, right, nums, target):
        if right - left <= 1:
            if nums[left] == target:
                return left
            if nums[right] == target:
                return right
            else:
                return -1

        middle = int((right + left) / 2)
        if nums[middle] == target:
            return middle
        elif target >= nums[left] and target < nums[middle]: # [4,5,T,7,1] Between the left and middle
            return self.middleSearch(left, middle, nums, target)
        elif nums[middle] < nums[left] and (target >= nums[left] or target < nums[middle]): # [6,7,T,1,2] Between left and middle, but the order is reversed. We know that the smallest values and the largest values lie somewhere in this interval
            return self.middleSearch(left, middle, nums, target)
        else:
            return self.middleSearch(middle, right, nums, target)

    def search(self, nums: List[int], target: int) -> int:
        return self.middleSearch(0, len(nums) - 1, nums, target)
```
Essentially, we have 3 cases. If our array is rotated, it will still be in some order. When we choose our middle value, we can also look at our left-most value in our array. 
### Base Case
`[T, 0]` OR `[T]` OR `[0]`
Our base case is two values in our subarray. This is simple enough, we just check each value and return the index of the target. If not present, return -1.
### Case 1 - Left < Middle
`[4, 5, T, 6, 8, 0, 1, 2]`
Here we see that our middle value is 8 and our left value is 4. Since we started with a sorted array, we know that the left side can be treated like a normal array, so we run normal binary search on it.
### Case 2 - Left > Middle
`[ 5, T, 6, 0, 1, 2, 4]`
Here, the left value is 5 and the right value is 0. Our target lies between the two indices, but a simple compare won’t work. If we naively check if the value is greater than the left side, we could also run into a case where the target value is 1, and we would look in the wrong spot. The trick is to realize that if the left is greater then the middle, the only values between are the highest and lowest values in our array. So, we want to check if the left is greater than the middle, and then if our target is greater than the left or smaller than the middle.
### Case 3 - Everything else
Since we know the target isn’t on the left side, it must be on the right side.

---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```