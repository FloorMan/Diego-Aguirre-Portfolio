---
title: Partition Equal Subset Sum
difficulty: Medium
topics:
  - array
  - DynamicProgramming
  - bitmask
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - DynamicProgramming
  - bitmask
date: 2025-09-24
time: 10:00
leetcode_id: 416
solved: true
review: false
---
[[LeetCode]]
[[SWE Prep]]
[[Dynamic Programming]]
## [Problem](https://leetcode.com/problems/partition-equal-subset-sum/description/)
Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_.

**Example 1:**

**Input:** nums = [1,5,11,5]
**Output:** true
**Explanation:** The array can be partitioned as [1, 5, 5] and [11].

**Example 2:**

**Input:** nums = [1,2,3,5]
**Output:** false
**Explanation:** The array cannot be partitioned into equal sum subsets.

**Constraints:**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`


## My Approach
### Time: $O(n \cdot \sum(x))$ or $O(n \cdot \max(nums))$
We used the knapsack approach to this problem. 

One way to solve this would be to use a hashmap to hold all of our calculated values, we would represent every single possible index up until the total sum of all the numbers. We we can make a subarray that sums up to half of this value, then we know that we could make two subarrays that are equal.

We create a set, and add a number to it. We keep adding numbers, and adding that number to every other number already in the set. By the end, we have every possible comination of sums. Then we just check to see if the sum is in our set and return true if it is. This is too long, however, as this approach in $O(n \cdot n)$.

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return False
        
        summation = sum(nums)

        if summation % 2 != 0:
            return False

        target = summation / 2
        dp = set()
        dp.add(0)

        for num in nums:
            tempDP = set()
            for sums in dp:
                if sums + num == target:
                    return True
                if sums + num < target:
                    tempDP.add(sums + num)
                tempDP.add(sums)
            dp = tempDP

        return False
```

The better solution here, however, is using the knapsack problem in an array. We create an array holding all the numbers between 0 and the sum / 2 (inclusive). 
We then set each value to `False`, indicating that that sum cannot currently be made by the numbers input. Then, we go through each number once, checking to see if either the value was already True (Indicating that we could already make that sum), or if the sum could be made with that number.

Once we reach the end, we just check to see if the index holding our sum/2 is `True`. If it is, return `True`.

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return False

        summation = sum(nums)

        if summation % 2 == 1:
            return False

        halfSum = summation // 2
        dp = [False] * (halfSum + 1)
        dp[0] = True

        for num in nums:
            for i in range(halfSum, -1, -1):
                dp[i] = dp[i] or (dp[i - num] if i >= num else False)
                if dp[halfSum]:
                    return True

        return dp[halfSum]
```

Lastly, the fastest solution is a cool bitmask. If we set our current sum to 0, we can mark each bit as the corresponding sum partition. 

For example, if we have a 1, we can set bit 1 to 1 since that is the current sum we can make. Next, we have a 5. We shift all our bits 5 times to the left, indicating that these are the new sums we can make. Now the 6 bit is lit, as well as the 1 bit. Finally, we light up the corresponding bit of our number, and check if the halfSum bit is lit.

It moves everything at once, so we donâ€™t have to manually calculate each position in an array, a much more expensive procedure.

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return False

        summation = sum(nums)

        if summation % 2 == 1:
            return False

        half = summation // 2

        i = 0
        for num in nums:
            i |= i << num
            i |= 1 << num
            if (i & (1 << half)):
                return True
        return False
```

---
## Solution

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
    #======backpack DP==============#
        #if(sum(nums)%2 != 0):
        #    return False
        #else:
        #    bagweight = sum(nums)//2
        #    dp = [float('-inf')] * (bagweight + 1)
        #    dp[0] = 0
        #    for num in nums:
        #        for j in range(bagweight,num-1,-1):
        #            dp[j] = max(dp[j],dp[j-num]+num)
        #    if(dp[-1] == bagweight):
        #        return True
        #    else:
        #        return False
    #=======bitset DP====#
        if(sum(nums)%2 != 0):
            return False
        else:
            maxhalf = sum(nums) // 2
            i = 0
            for num in nums:
                i |= i << num
                i |= 1 << num
                if(i & (1 << maxhalf)):
                    return True
            return False
```


---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```