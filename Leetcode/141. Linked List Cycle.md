---
title: Linked List Cycle
difficulty: Easy
topics:
  - Hash Table
  - Linked Lists
  - Two Pointer
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-03-14
time: 6:33
leetcode_id: 141
solved: true
review: true
---
[[LeetCode]]
[[Linked Lists]]
## [Problem](https://leetcode.com/problems/linked-list-cycle/description/)
Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.

Return `true` _if there is a cycle in the linked list_. Otherwise, return `false`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

**Input:** head = [3,2,0,-4], pos = 1
**Output:** true
**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

**Input:** head = [1,2], pos = 0
**Output:** true
**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.

**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

**Input:** head = [1], pos = -1
**Output:** false
**Explanation:** There is no cycle in the linked list.

**Constraints:**

- The number of the nodes in the list is in the range `[0, 104]`.
- `-105 <= Node.val <= 105`
- `pos` is `-1` or a **valid index** in the linked-list.

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?

## My Approach
### Time: O(n)
In our approach, we go through each node in the list, setting the value to `None`. If we reach a node in our list that has a value of `None`, then we know we have already visited that node, and a cycle exists.
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        currNode = head
        if head is None:
            return False
        while currNode.next is not None:
            currNode.val = None
            if currNode.next.val is None:
                return True
            currNode = currNode.next  
        return False
```
Other methods exist, such as the two pointer approach. This one is better because it does not modify the array, in case that is important.

We have two pointers, one fast and one slow. The slow pointer moves through the list normally. The fast pointer will move twice as fast as the slow, so if a cycle does exist, it will eventually line up with the slow pointer. If there is no cycle, then the fast pointer will simply hit the end. 
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
	    slow = fast = head
	   while fast and fast.next: # This handles our base case of 0 and 1
			slow = slow.next
			fast=fast.next.next
			if fast == slow:      # If our two pointers are equal, cycle
			   return True

		return False # We have hit the end of the list, no cycle
```


---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```