---
title: Decode Ways
difficulty: Medium
topics:
  - String
  - DynamicProgramming
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-10-01
time: 18:53
leetcode_id: 91
solved: true
review: true
---
[[LeetCode]]
[[SWE Prep]]
[[Dynamic Programming]]
## [Problem](https://leetcode.com/problems/decode-ways/description/)
You have intercepted a secret message encoded as a string of numbers. The message is **decoded** via the following mapping:

`"1" -> 'A'   "2" -> 'B'   ...   "25" -> 'Y'   "26" -> 'Z'`

However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (`"2"` and `"5"` vs `"25"`).

For example, `"11106"` can be decoded into:

- `"AAJF"` with the grouping `(1, 1, 10, 6)`
- `"KJF"` with the grouping `(11, 10, 6)`
- The grouping `(1, 11, 06)` is invalid because `"06"` is not a valid code (only `"6"` is valid).

Note: there may be strings that are impossible to decode.  
  
Given a string s containing only digits, return the **number of ways** to **decode** it. If the entire string cannot be decoded in any valid way, return `0`.

The test cases are generated so that the answer fits in a **32-bit** integer.

**Example 1:**

**Input:** s = "12"

**Output:** 2

**Explanation:**

"12" could be decoded as "AB" (1 2) or "L" (12).

**Example 2:**

**Input:** s = "226"

**Output:** 3

**Explanation:**

"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).

**Example 3:**

**Input:** s = "06"

**Output:** 0

**Explanation:**

"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.

**Constraints:**

- `1 <= s.length <= 100`
- `s` contains only digits and may contain leading zero(s).


## My Approach
### Time: $O(n)$

Think of this as the stair problem. In the stair problem, we can either take one step or two steps to get to a stair. The unique amount of ways to get to the top stair is determined by the unique amount of ways to get to the previous 2 stairs. This problem is very similar, instead of stairs, it is groupings of numbers we can take. Depending on the conditions, we can either include our new number in our groupings. If it’s by itself, we count the unique amount of groupings to get to the i-1 index. We do the same to count the unique pairings of the i-2 column (our two step).

We want to check if the previous number of decoding’s is not 0. If it isn’t, then we can add all the unique decodings to that index. Then we check if the previous two numbers are already a pair. If they air, then we can add all of those decodings to our index as well, since adding this number would make a new decoding. Then, we just check the final index for the total amount of decodings.


```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if s[0] == '0':
            return 0

        dp = [0] * (len(s) + 1)
        dp[0], dp[1] = 1, 1

        for i in range(2, len(s) + 1):
            one = int(s[i - 1])
            two = int(s[i - 2:i])

            if two == 0:
                return 0

            if one != 0:
                dp[i] += dp[i - 1]
            if 10 <= two <= 26:
                dp[i] += dp[i - 2]
            
        return dp[-1]
```




---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```