---
title: Word Search II
difficulty: Hard
topics:
  - array
  - String
  - Backtracking
  - trie
  - matrix
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-09-17
time: 25:01
leetcode_id: 212
solved: true
review: true
---
[[LeetCode]]

## [Problem](https://leetcode.com/problems/word-search-ii/description/)
Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.

Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

**Input:** board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
**Output:** ["eat","oath"]

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

**Input:** board = [["a","b"],["c","d"]], words = ["abcb"]
**Output:** []

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` is a lowercase English letter.
- `1 <= words.length <= 3 * 104`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters.
- All the strings of `words` are unique.


## My Approach
### Time: $O(n^2)$
My first thought to approaching this problem was to use a trie. This is similar to the word hunt solver I made, but with only horizontal and vertical movement. 

We first put all the dictionary words into a Trie. Then we start at each space in the grid, recursively running through each possible space. We check to see if we’ve moved to that space before, and if the location is valid, we check if the character exists as part of a word. If not, we backtrack.

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isWord = False
        self.wholeWord = ""
  

  
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        root = TrieNode()
  
        for word in words:
            #print("Adding word: ", word)
            curr = root
            for char in word:
                if char not in curr.children:
                    curr.children[char] = TrieNode()
                curr = curr.children[char]
                #print("Added ", char, " to trie.")
            curr.isWord = True
            curr.wholeWord = word
        visited =[[False for _ in range(len(board[0]))] for _ in range(len(board))]
       directions = [[-1, 0], [1, 0], [0, -1], [0, 1]] # Up, down, left, right
        answers = set()
  
        def recVisit(currPosition, currNode):
            row, col = currPosition
            if row >= len(board) or row < 0:
                # print("Row Out of Bounds")
                return
            if col >= len(board[0]) or col < 0:
                # print("Col Out of Bounds")
                return
            if visited[row][col]:
                # print("Already visited!")
                return
            currChar = board[row][col]          
            # print(currChar)
            if currChar not in currNode.children:
                return
            currNode = currNode.children[currChar]
  
            visited[row][col] = True
            if currNode.isWord:
                # print("Word found: ", currNode.wholeWord)
                answers.add(currNode.wholeWord)
  
            for dir in directions:
                # print("Going to: ", [row + dir[0], col + dir[1]])
                recVisit([row + dir[0], col + dir[1]], currNode)
            visited[row][col] = False
  
        for row in range(len(board)):
            for col in range(len(board[0])):
                # print("new sequence")
                recVisit([row, col], root)
        return list(answers)
```



---
## Solution

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isWord = False
	    self.wholeWord = ""
        self.count = 0

class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        
        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]
        # Add the words to the tree
        root = TrieNode()
        for word in words:
            currNode = root
            root.count += 1
            for char in word:
                if char not in currNode.children:
                    currNode.children[char] = TrieNode()
                currNode = currNode.children[char]
                currNode.count += 1
            currNode.isWord = True
            currNode.wholeWord = word
        
        # Begin recursive search
        answers = set()
        def searchWords(currRow, currCol, currNode):
            if currRow < 0 or currRow >= len(board) or currCol < 0 or currCol >= len(board[0]):
                return
            if visited[currRow][currCol]:
                return
            
            currChar = board[currRow][currCol]
            if currChar not in currNode.children:
                return
            currNode = currNode.children[currChar]
            
            if currNode.count <= 0:
                return
            visited[currRow][currCol] = True

            if currNode.isWord and currNode.wholeWord not in answers:
                answers.add(currNode.wholeWord)
                currNode.count -= 1

            searchWords(currRow + 1, currCol, currNode)
            searchWords(currRow, currCol + 1, currNode)
            searchWords(currRow - 1, currCol, currNode)
            searchWords(currRow, currCol - 1, currNode)

            visited[currRow][currCol] = False

        for row in range(len(board)):
            for col in range(len(board[0])):
                searchWords(row, col, root)
        return list(answers)
```


---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```