---
title: Top K Frequent Elements
difficulty: Medium
topics:
  - array
  - Hash Table
  - Divide and Conquer
  - Sorting
  - Heap
  - Priority Queue
  - Bucket Sort
  - Counting
  - Quickselect
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-03-30
time: 6:00
leetcode_id: 347
solved: true
review: true
---
[[LeetCode]]
[[Heaps]]
## [Problem](https://leetcode.com/problems/top-k-frequent-elements/description/)
Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.

**Example 1:**

**Input:** nums = [1,1,1,2,2,3], k = 2
**Output:** [1,2]

**Example 2:**

**Input:** nums = [1], k = 1
**Output:** [1]

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `k` is in the range `[1, the number of unique elements in the array]`.
- It is **guaranteed** that the answer is **unique**.

**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.


## My Approach
### Time: 

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        hashmap = {}
        heap = []

  
        for num in nums:
            hashmap[num] = hashmap.get(num, 0) + 1
        for key, val in hashmap.items(): # The number is the key, freq is value
            if len(heap) == k:
                heapq.heappushpop(heap, (val, key))
            else:
                heapq.heappush(heap, (val, key))
  
        return [key for (val, key) in heap]
```
We count the frequency as we go through the list, then we append the top numbers to a heap. We use the frequency as the value in our hashmap, and the number as the key. Then we sort the heap using the frequency as the key.





---
## [Solution](https://leetcode.com/problems/top-k-frequent-elements/solutions/5513122/video-2-solutions)




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```