---
title: Rotting Oranges
difficulty: Medium
topics:
  - array
  - DFS
  - matrix
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-03-29
time: 24:33
leetcode_id: 994
solved: true
review: true
---
[[LeetCode]]
[[SWE Prep]]
[[Graphs]]
## [Problem](https://leetcode.com/problems/rotting-oranges/description/)
You are given an `m x n` `grid` where each cell can have one of three values:

- `0` representing an empty cell,
- `1` representing a fresh orange, or
- `2` representing a rotten orange.

Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.

Return _the minimum number of minutes that must elapse until no cell has a fresh orange_. If _this is impossible, return_ `-1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)

**Input:** grid = [[2,1,1],[1,1,0],[0,1,1]]
**Output:** 4

**Example 2:**

**Input:** grid = [[2,1,1],[0,1,1],[1,0,1]]
**Output:** -1
**Explanation:** The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.

**Example 3:**

**Input:** grid = [[0,2]]
**Output:** 0
**Explanation:** Since there are already no fresh oranges at minute 0, the answer is just 0.

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 10`
- `grid[i][j]` is `0`, `1`, or `2`.


## My Approach
### Time: 
```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        directions = [[-1,0], [1,0], [0,1], [0,-1]]
        minutes = 0
        q = deque()
  
        # Get the location of all the rotting oranges
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 2:
                    q.append((row,col))

  
        while q:
            minutes += 1
            for _ in range(len(q)):
                row, col = q.popleft()
                for dr, dc in directions:
                    nr, nc = row + dr, col + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                        q.append((nr,nc))
                        grid[nr][nc] = 2
        minutes = max(0, minutes - 1)
  
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 1:
                    return -1
  
        return minutes
```

We do a BFS search through the graph. We start by finding the location of all the rotting oranges. Then we go through each level and add all the new rotting oranges to the queue. We then have to account for the first level by using the max(0, minutes - 1), for the edge case where there are no oranges at all.

---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```