---
title: Subsets
difficulty: Medium
topics:
  - array
  - Backtracking
  - Bit Manipulation
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
  - Recursion
date: 2025-03-07
time: 22:00
leetcode_id: 78
solved: true
review: true
---
[[LeetCode]]
[[Recursion]]
## [Problem](https://leetcode.com/problems/subsets/description/)
Given an integer arrayÂ `nums`Â ofÂ **unique**Â elements, returnÂ _all possible_Â _subsets_Â _(the power set)_.

The solution setÂ **must not**Â contain duplicate subsets. Return the solution inÂ **any order**.

**Example 1:**

**Input:** nums = [1,2,3]
**Output:** [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

**Example 2:**

**Input:** nums = [0]
**Output:** [[],[0]]

**Constraints:**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the numbers ofÂ `nums`Â areÂ **unique**.

## Thoughts


## My Approach
### Time: O($2^{\text{n}}$)
```python
class Solution:
Â  Â  def subsets(self, nums: List[int]) -> List[List[int]]:
Â  Â  Â  Â  def dfs(start, path):
Â  Â  Â  Â  Â  Â  result.append(path)
Â  Â  Â  Â  Â  Â  for i in range(start, len(nums)):
Â  Â  Â  Â  Â  Â  Â  Â  dfs(i + 1, path + [nums[i]])
Â  Â  Â  Â  
Â  Â  Â  Â  result = []
Â  Â  Â  Â  dfs(0, [])
Â  Â  Â  Â  return result
```






---
## Solution

### Bit ManipulationðŸ˜Ž:

- Use bit manipulation to generate all possible combinations.
- For a set with n elements, there are 2^n possible subsets.
- Iterate from 0 to 2^n - 1 and for each integer, consider the set bits as indices of elements to include in the subset.
- This approach is efficient in terms of time complexity, as it avoids recursion and extra space.

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        result = []
        for i in range(1 << n):
            subset = []
            for j in range(n):
                if i & (1 << j):
                    subset.append(nums[j])
            result.append(subset)
        return result
```

### Iterative Approach (Generating All Subsets):
- Start with an empty subset and gradually build it.
- Iterate through each element in the given set.
- For each element, clone the existing subsets, add the current element to each cloned subset, and then add these subsets to the result.
- This approach iterates through the set only once and builds subsets incrementally.
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = [[]]
        for num in nums:
            result += [curr + [num] for curr in result]
        return result
```


---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```