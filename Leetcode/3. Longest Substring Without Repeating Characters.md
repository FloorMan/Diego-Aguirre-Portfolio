---
title: Longest Substring Without Repeating Characters
difficulty: Medium
topics:
  - Hash Table
  - Sliding Window
  - String
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-03-03
time: 18:00
leetcode_id: 3
solved: true
review: false
---
[[LeetCode]]
[[Strings]]
## Problem
[Link to Question](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
Given a string `s`, find the length of the **longest** **substring** without duplicate characters.

**Example 1:**

**Input:** s = "abcabcbb"
**Output:** 3
**Explanation:** The answer is "abc", with the length of 3.

**Example 2:**

**Input:** s = "bbbbb"
**Output:** 1
**Explanation:** The answer is "b", with the length of 1.

**Example 3:**

**Input:** s = "pwwkew"
**Output:** 3
**Explanation:** The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

**Constraints:**

- `0 <= s.length <= 5 * 104`
- `s` consists of English letters, digits, symbols and spaces.

## Thoughts


## My Approach
### Time: O(n) w/ O(1) space
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        sequence = [0] * 95 # from 32 to 126 in ASCII
  
        leftPtr = 0
        longestLen = 0
        for index in range(len(s)):
            currChar = ord(s[index]) - 32
            if sequence[currChar] == 1: # This means we have a repeat
                while leftPtr < index and s[leftPtr] != s[index]:
                    sequence[ord(s[leftPtr]) - 32] = 0
                    leftPtr += 1
                leftPtr += 1
            else:
                sequence[currChar] += 1
            longestLen = max(longestLen, index - leftPtr + 1)
  
        return longestLen
```
We have an array holding the number of occurrences of each character. As we go through, we add it to the array. If we see that the array is already holding an occurrence of the character, we move our left pointer until we reach that character again, removing any other character from our array as well. This gets us our greatest unique substring.

Make sure to check for “off-by-one“ errors, my array wasn’t big enough the first time to hold all the symbols (i need 95 spaces, not 94. It’s inclusive, not exclusive.)

---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```