---
title: Reverse Bits
difficulty: Easy
topics:
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-10-14
time: 7:12
leetcode_id: 190
solved: true
review: true
---
[[LeetCode]]
[[SWE Prep]]
[[Binary]]
## [Problem](https://leetcode.com/problems/reverse-bits/description/)
Reverse bits of a given 32 bits signed integer.

**Example 1:**

**Input:** n = 43261596

**Output:** 964176192

**Explanation:**

|Integer|Binary|
|---|---|
|43261596|00000010100101000001111010011100|
|964176192|00111001011110000010100101000000|

**Example 2:**

**Input:** n = 2147483644

**Output:** 1073741822

**Explanation:**

|Integer|Binary|
|---|---|
|2147483644|01111111111111111111111111111100|
|1073741822|00111111111111111111111111111110|

**Constraints:**

- `0 <= n <= 231 - 2`
- `n` is even.

**Follow up:** If this function is called many times, how would you optimize it?


## My Approach
### Time: $O(n)$

Simple solution, with some edge cases. Since we know that the number is even, we can shift our number to the left once and add a bit at the left to keep track of when we should stop.

We then keep shifting our number to the right; If the bit is set, we add a bit to our answer, and then shift that to the left.
Once we get to the end, we shift backwards twice (to account for the extra set bit)
```python
class Solution:
    def reverseBits(self, n: int) -> int:
        ans = 0
        # 32 bit even integer
        n = n >> 1
        n = n ^ 0x80000000

        while n:
            ans += n & 1
            ans = ans << 1
            n = n >> 1

        return (ans >> 2)
```


---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```