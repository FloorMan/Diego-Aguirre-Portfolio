---
title: House Robber
difficulty: Medium
topics:
  - array
  - DynamicProgramming
tags:
  - Algorithms
  - coding
  - DSA
  - leetcode
date: 2025-09-24
time: 14:45
leetcode_id: 198
solved: true
review: true
---
[[LeetCode]]
[[SWE Prep]]
[[Dynamic Programming]]
## [Problem](https://leetcode.com/problems/house-robber/description/)
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.

**Example 1:**

**Input:** nums = [1,2,3,1]
**Output:** 4
**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.

**Example 2:**

**Input:** nums = [2,7,9,3,1]
**Output:** 12
**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`


## My Approach
### Time: $O(n)$

We can either rob this house, or skip it and start again:

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        
        if len(nums) == 1:
            return nums[0]
        if len(nums) == 2:
            return max(nums[0], nums[1])

        # now we know there are at least 3 houses
        nums[2] += nums[0]
        for house in range(3, len(nums)):
            nums[house] += max(nums[house - 2], nums[house - 3])
            
        return max(nums[-1], nums[-2])
```


---
## Solution




---
## Related Problems
```dataview
TABLE difficulty, topics
FROM "LeetCode"
FLATTEN topics AS topic
WHERE contains(this.topics, topic) AND file.name != this.file.name
```